// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ThreeAxisSensor {
  double get x => throw _privateConstructorUsedError;
  double get y => throw _privateConstructorUsedError;
  double get z => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ThreeAxisSensorCopyWith<ThreeAxisSensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThreeAxisSensorCopyWith<$Res> {
  factory $ThreeAxisSensorCopyWith(
          ThreeAxisSensor value, $Res Function(ThreeAxisSensor) then) =
      _$ThreeAxisSensorCopyWithImpl<$Res>;
  $Res call({double x, double y, double z});
}

/// @nodoc
class _$ThreeAxisSensorCopyWithImpl<$Res>
    implements $ThreeAxisSensorCopyWith<$Res> {
  _$ThreeAxisSensorCopyWithImpl(this._value, this._then);

  final ThreeAxisSensor _value;
  // ignore: unused_field
  final $Res Function(ThreeAxisSensor) _then;

  @override
  $Res call({
    Object? x = freezed,
    Object? y = freezed,
    Object? z = freezed,
  }) {
    return _then(_value.copyWith(
      x: x == freezed
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: y == freezed
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
      z: z == freezed
          ? _value.z
          : z // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$$_ThreeAxisSensorCopyWith<$Res>
    implements $ThreeAxisSensorCopyWith<$Res> {
  factory _$$_ThreeAxisSensorCopyWith(
          _$_ThreeAxisSensor value, $Res Function(_$_ThreeAxisSensor) then) =
      __$$_ThreeAxisSensorCopyWithImpl<$Res>;
  @override
  $Res call({double x, double y, double z});
}

/// @nodoc
class __$$_ThreeAxisSensorCopyWithImpl<$Res>
    extends _$ThreeAxisSensorCopyWithImpl<$Res>
    implements _$$_ThreeAxisSensorCopyWith<$Res> {
  __$$_ThreeAxisSensorCopyWithImpl(
      _$_ThreeAxisSensor _value, $Res Function(_$_ThreeAxisSensor) _then)
      : super(_value, (v) => _then(v as _$_ThreeAxisSensor));

  @override
  _$_ThreeAxisSensor get _value => super._value as _$_ThreeAxisSensor;

  @override
  $Res call({
    Object? x = freezed,
    Object? y = freezed,
    Object? z = freezed,
  }) {
    return _then(_$_ThreeAxisSensor(
      x: x == freezed
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: y == freezed
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
      z: z == freezed
          ? _value.z
          : z // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_ThreeAxisSensor implements _ThreeAxisSensor {
  const _$_ThreeAxisSensor({required this.x, required this.y, required this.z});

  @override
  final double x;
  @override
  final double y;
  @override
  final double z;

  @override
  String toString() {
    return 'ThreeAxisSensor(x: $x, y: $y, z: $z)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ThreeAxisSensor &&
            const DeepCollectionEquality().equals(other.x, x) &&
            const DeepCollectionEquality().equals(other.y, y) &&
            const DeepCollectionEquality().equals(other.z, z));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(x),
      const DeepCollectionEquality().hash(y),
      const DeepCollectionEquality().hash(z));

  @JsonKey(ignore: true)
  @override
  _$$_ThreeAxisSensorCopyWith<_$_ThreeAxisSensor> get copyWith =>
      __$$_ThreeAxisSensorCopyWithImpl<_$_ThreeAxisSensor>(this, _$identity);
}

abstract class _ThreeAxisSensor implements ThreeAxisSensor {
  const factory _ThreeAxisSensor(
      {required final double x,
      required final double y,
      required final double z}) = _$_ThreeAxisSensor;

  @override
  double get x;
  @override
  double get y;
  @override
  double get z;
  @override
  @JsonKey(ignore: true)
  _$$_ThreeAxisSensorCopyWith<_$_ThreeAxisSensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TwoAxisSensor {
  double get x => throw _privateConstructorUsedError;
  double get y => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TwoAxisSensorCopyWith<TwoAxisSensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TwoAxisSensorCopyWith<$Res> {
  factory $TwoAxisSensorCopyWith(
          TwoAxisSensor value, $Res Function(TwoAxisSensor) then) =
      _$TwoAxisSensorCopyWithImpl<$Res>;
  $Res call({double x, double y});
}

/// @nodoc
class _$TwoAxisSensorCopyWithImpl<$Res>
    implements $TwoAxisSensorCopyWith<$Res> {
  _$TwoAxisSensorCopyWithImpl(this._value, this._then);

  final TwoAxisSensor _value;
  // ignore: unused_field
  final $Res Function(TwoAxisSensor) _then;

  @override
  $Res call({
    Object? x = freezed,
    Object? y = freezed,
  }) {
    return _then(_value.copyWith(
      x: x == freezed
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: y == freezed
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$$_TwoAxisSensorCopyWith<$Res>
    implements $TwoAxisSensorCopyWith<$Res> {
  factory _$$_TwoAxisSensorCopyWith(
          _$_TwoAxisSensor value, $Res Function(_$_TwoAxisSensor) then) =
      __$$_TwoAxisSensorCopyWithImpl<$Res>;
  @override
  $Res call({double x, double y});
}

/// @nodoc
class __$$_TwoAxisSensorCopyWithImpl<$Res>
    extends _$TwoAxisSensorCopyWithImpl<$Res>
    implements _$$_TwoAxisSensorCopyWith<$Res> {
  __$$_TwoAxisSensorCopyWithImpl(
      _$_TwoAxisSensor _value, $Res Function(_$_TwoAxisSensor) _then)
      : super(_value, (v) => _then(v as _$_TwoAxisSensor));

  @override
  _$_TwoAxisSensor get _value => super._value as _$_TwoAxisSensor;

  @override
  $Res call({
    Object? x = freezed,
    Object? y = freezed,
  }) {
    return _then(_$_TwoAxisSensor(
      x: x == freezed
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: y == freezed
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_TwoAxisSensor implements _TwoAxisSensor {
  const _$_TwoAxisSensor({required this.x, required this.y});

  @override
  final double x;
  @override
  final double y;

  @override
  String toString() {
    return 'TwoAxisSensor(x: $x, y: $y)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TwoAxisSensor &&
            const DeepCollectionEquality().equals(other.x, x) &&
            const DeepCollectionEquality().equals(other.y, y));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(x),
      const DeepCollectionEquality().hash(y));

  @JsonKey(ignore: true)
  @override
  _$$_TwoAxisSensorCopyWith<_$_TwoAxisSensor> get copyWith =>
      __$$_TwoAxisSensorCopyWithImpl<_$_TwoAxisSensor>(this, _$identity);
}

abstract class _TwoAxisSensor implements TwoAxisSensor {
  const factory _TwoAxisSensor(
      {required final double x, required final double y}) = _$_TwoAxisSensor;

  @override
  double get x;
  @override
  double get y;
  @override
  @JsonKey(ignore: true)
  _$$_TwoAxisSensorCopyWith<_$_TwoAxisSensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AngleSensor {
  double get pitch => throw _privateConstructorUsedError;
  double get roll => throw _privateConstructorUsedError;
  double get yaw => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AngleSensorCopyWith<AngleSensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AngleSensorCopyWith<$Res> {
  factory $AngleSensorCopyWith(
          AngleSensor value, $Res Function(AngleSensor) then) =
      _$AngleSensorCopyWithImpl<$Res>;
  $Res call({double pitch, double roll, double yaw});
}

/// @nodoc
class _$AngleSensorCopyWithImpl<$Res> implements $AngleSensorCopyWith<$Res> {
  _$AngleSensorCopyWithImpl(this._value, this._then);

  final AngleSensor _value;
  // ignore: unused_field
  final $Res Function(AngleSensor) _then;

  @override
  $Res call({
    Object? pitch = freezed,
    Object? roll = freezed,
    Object? yaw = freezed,
  }) {
    return _then(_value.copyWith(
      pitch: pitch == freezed
          ? _value.pitch
          : pitch // ignore: cast_nullable_to_non_nullable
              as double,
      roll: roll == freezed
          ? _value.roll
          : roll // ignore: cast_nullable_to_non_nullable
              as double,
      yaw: yaw == freezed
          ? _value.yaw
          : yaw // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$$_AngleSensorCopyWith<$Res>
    implements $AngleSensorCopyWith<$Res> {
  factory _$$_AngleSensorCopyWith(
          _$_AngleSensor value, $Res Function(_$_AngleSensor) then) =
      __$$_AngleSensorCopyWithImpl<$Res>;
  @override
  $Res call({double pitch, double roll, double yaw});
}

/// @nodoc
class __$$_AngleSensorCopyWithImpl<$Res> extends _$AngleSensorCopyWithImpl<$Res>
    implements _$$_AngleSensorCopyWith<$Res> {
  __$$_AngleSensorCopyWithImpl(
      _$_AngleSensor _value, $Res Function(_$_AngleSensor) _then)
      : super(_value, (v) => _then(v as _$_AngleSensor));

  @override
  _$_AngleSensor get _value => super._value as _$_AngleSensor;

  @override
  $Res call({
    Object? pitch = freezed,
    Object? roll = freezed,
    Object? yaw = freezed,
  }) {
    return _then(_$_AngleSensor(
      pitch: pitch == freezed
          ? _value.pitch
          : pitch // ignore: cast_nullable_to_non_nullable
              as double,
      roll: roll == freezed
          ? _value.roll
          : roll // ignore: cast_nullable_to_non_nullable
              as double,
      yaw: yaw == freezed
          ? _value.yaw
          : yaw // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_AngleSensor implements _AngleSensor {
  const _$_AngleSensor(
      {required this.pitch, required this.roll, required this.yaw});

  @override
  final double pitch;
  @override
  final double roll;
  @override
  final double yaw;

  @override
  String toString() {
    return 'AngleSensor(pitch: $pitch, roll: $roll, yaw: $yaw)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AngleSensor &&
            const DeepCollectionEquality().equals(other.pitch, pitch) &&
            const DeepCollectionEquality().equals(other.roll, roll) &&
            const DeepCollectionEquality().equals(other.yaw, yaw));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(pitch),
      const DeepCollectionEquality().hash(roll),
      const DeepCollectionEquality().hash(yaw));

  @JsonKey(ignore: true)
  @override
  _$$_AngleSensorCopyWith<_$_AngleSensor> get copyWith =>
      __$$_AngleSensorCopyWithImpl<_$_AngleSensor>(this, _$identity);
}

abstract class _AngleSensor implements AngleSensor {
  const factory _AngleSensor(
      {required final double pitch,
      required final double roll,
      required final double yaw}) = _$_AngleSensor;

  @override
  double get pitch;
  @override
  double get roll;
  @override
  double get yaw;
  @override
  @JsonKey(ignore: true)
  _$$_AngleSensorCopyWith<_$_AngleSensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SensorResponse {
  AngleSensor? get angles => throw _privateConstructorUsedError;
  ThreeAxisSensor? get accelerometer => throw _privateConstructorUsedError;
  ThreeAxisSensor? get gyro => throw _privateConstructorUsedError;
  TwoAxisSensor? get position => throw _privateConstructorUsedError;
  TwoAxisSensor? get velocity => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SensorResponseCopyWith<SensorResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SensorResponseCopyWith<$Res> {
  factory $SensorResponseCopyWith(
          SensorResponse value, $Res Function(SensorResponse) then) =
      _$SensorResponseCopyWithImpl<$Res>;
  $Res call(
      {AngleSensor? angles,
      ThreeAxisSensor? accelerometer,
      ThreeAxisSensor? gyro,
      TwoAxisSensor? position,
      TwoAxisSensor? velocity});

  $AngleSensorCopyWith<$Res>? get angles;
  $ThreeAxisSensorCopyWith<$Res>? get accelerometer;
  $ThreeAxisSensorCopyWith<$Res>? get gyro;
  $TwoAxisSensorCopyWith<$Res>? get position;
  $TwoAxisSensorCopyWith<$Res>? get velocity;
}

/// @nodoc
class _$SensorResponseCopyWithImpl<$Res>
    implements $SensorResponseCopyWith<$Res> {
  _$SensorResponseCopyWithImpl(this._value, this._then);

  final SensorResponse _value;
  // ignore: unused_field
  final $Res Function(SensorResponse) _then;

  @override
  $Res call({
    Object? angles = freezed,
    Object? accelerometer = freezed,
    Object? gyro = freezed,
    Object? position = freezed,
    Object? velocity = freezed,
  }) {
    return _then(_value.copyWith(
      angles: angles == freezed
          ? _value.angles
          : angles // ignore: cast_nullable_to_non_nullable
              as AngleSensor?,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer // ignore: cast_nullable_to_non_nullable
              as ThreeAxisSensor?,
      gyro: gyro == freezed
          ? _value.gyro
          : gyro // ignore: cast_nullable_to_non_nullable
              as ThreeAxisSensor?,
      position: position == freezed
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TwoAxisSensor?,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as TwoAxisSensor?,
    ));
  }

  @override
  $AngleSensorCopyWith<$Res>? get angles {
    if (_value.angles == null) {
      return null;
    }

    return $AngleSensorCopyWith<$Res>(_value.angles!, (value) {
      return _then(_value.copyWith(angles: value));
    });
  }

  @override
  $ThreeAxisSensorCopyWith<$Res>? get accelerometer {
    if (_value.accelerometer == null) {
      return null;
    }

    return $ThreeAxisSensorCopyWith<$Res>(_value.accelerometer!, (value) {
      return _then(_value.copyWith(accelerometer: value));
    });
  }

  @override
  $ThreeAxisSensorCopyWith<$Res>? get gyro {
    if (_value.gyro == null) {
      return null;
    }

    return $ThreeAxisSensorCopyWith<$Res>(_value.gyro!, (value) {
      return _then(_value.copyWith(gyro: value));
    });
  }

  @override
  $TwoAxisSensorCopyWith<$Res>? get position {
    if (_value.position == null) {
      return null;
    }

    return $TwoAxisSensorCopyWith<$Res>(_value.position!, (value) {
      return _then(_value.copyWith(position: value));
    });
  }

  @override
  $TwoAxisSensorCopyWith<$Res>? get velocity {
    if (_value.velocity == null) {
      return null;
    }

    return $TwoAxisSensorCopyWith<$Res>(_value.velocity!, (value) {
      return _then(_value.copyWith(velocity: value));
    });
  }
}

/// @nodoc
abstract class _$$_SensorResponseCopyWith<$Res>
    implements $SensorResponseCopyWith<$Res> {
  factory _$$_SensorResponseCopyWith(
          _$_SensorResponse value, $Res Function(_$_SensorResponse) then) =
      __$$_SensorResponseCopyWithImpl<$Res>;
  @override
  $Res call(
      {AngleSensor? angles,
      ThreeAxisSensor? accelerometer,
      ThreeAxisSensor? gyro,
      TwoAxisSensor? position,
      TwoAxisSensor? velocity});

  @override
  $AngleSensorCopyWith<$Res>? get angles;
  @override
  $ThreeAxisSensorCopyWith<$Res>? get accelerometer;
  @override
  $ThreeAxisSensorCopyWith<$Res>? get gyro;
  @override
  $TwoAxisSensorCopyWith<$Res>? get position;
  @override
  $TwoAxisSensorCopyWith<$Res>? get velocity;
}

/// @nodoc
class __$$_SensorResponseCopyWithImpl<$Res>
    extends _$SensorResponseCopyWithImpl<$Res>
    implements _$$_SensorResponseCopyWith<$Res> {
  __$$_SensorResponseCopyWithImpl(
      _$_SensorResponse _value, $Res Function(_$_SensorResponse) _then)
      : super(_value, (v) => _then(v as _$_SensorResponse));

  @override
  _$_SensorResponse get _value => super._value as _$_SensorResponse;

  @override
  $Res call({
    Object? angles = freezed,
    Object? accelerometer = freezed,
    Object? gyro = freezed,
    Object? position = freezed,
    Object? velocity = freezed,
  }) {
    return _then(_$_SensorResponse(
      angles: angles == freezed
          ? _value.angles
          : angles // ignore: cast_nullable_to_non_nullable
              as AngleSensor?,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer // ignore: cast_nullable_to_non_nullable
              as ThreeAxisSensor?,
      gyro: gyro == freezed
          ? _value.gyro
          : gyro // ignore: cast_nullable_to_non_nullable
              as ThreeAxisSensor?,
      position: position == freezed
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TwoAxisSensor?,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as TwoAxisSensor?,
    ));
  }
}

/// @nodoc

class _$_SensorResponse implements _SensorResponse {
  const _$_SensorResponse(
      {this.angles,
      this.accelerometer,
      this.gyro,
      this.position,
      this.velocity});

  @override
  final AngleSensor? angles;
  @override
  final ThreeAxisSensor? accelerometer;
  @override
  final ThreeAxisSensor? gyro;
  @override
  final TwoAxisSensor? position;
  @override
  final TwoAxisSensor? velocity;

  @override
  String toString() {
    return 'SensorResponse(angles: $angles, accelerometer: $accelerometer, gyro: $gyro, position: $position, velocity: $velocity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SensorResponse &&
            const DeepCollectionEquality().equals(other.angles, angles) &&
            const DeepCollectionEquality()
                .equals(other.accelerometer, accelerometer) &&
            const DeepCollectionEquality().equals(other.gyro, gyro) &&
            const DeepCollectionEquality().equals(other.position, position) &&
            const DeepCollectionEquality().equals(other.velocity, velocity));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(angles),
      const DeepCollectionEquality().hash(accelerometer),
      const DeepCollectionEquality().hash(gyro),
      const DeepCollectionEquality().hash(position),
      const DeepCollectionEquality().hash(velocity));

  @JsonKey(ignore: true)
  @override
  _$$_SensorResponseCopyWith<_$_SensorResponse> get copyWith =>
      __$$_SensorResponseCopyWithImpl<_$_SensorResponse>(this, _$identity);
}

abstract class _SensorResponse implements SensorResponse {
  const factory _SensorResponse(
      {final AngleSensor? angles,
      final ThreeAxisSensor? accelerometer,
      final ThreeAxisSensor? gyro,
      final TwoAxisSensor? position,
      final TwoAxisSensor? velocity}) = _$_SensorResponse;

  @override
  AngleSensor? get angles;
  @override
  ThreeAxisSensor? get accelerometer;
  @override
  ThreeAxisSensor? get gyro;
  @override
  TwoAxisSensor? get position;
  @override
  TwoAxisSensor? get velocity;
  @override
  @JsonKey(ignore: true)
  _$$_SensorResponseCopyWith<_$_SensorResponse> get copyWith =>
      throw _privateConstructorUsedError;
}
