// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ThreeAxisSensorTearOff {
  const _$ThreeAxisSensorTearOff();

// ignore: unused_element
  _ThreeAxisSensor call({double x, double y, double z}) {
    return _ThreeAxisSensor(
      x: x,
      y: y,
      z: z,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ThreeAxisSensor = _$ThreeAxisSensorTearOff();

/// @nodoc
mixin _$ThreeAxisSensor {
  double get x;
  double get y;
  double get z;

  $ThreeAxisSensorCopyWith<ThreeAxisSensor> get copyWith;
}

/// @nodoc
abstract class $ThreeAxisSensorCopyWith<$Res> {
  factory $ThreeAxisSensorCopyWith(
          ThreeAxisSensor value, $Res Function(ThreeAxisSensor) then) =
      _$ThreeAxisSensorCopyWithImpl<$Res>;
  $Res call({double x, double y, double z});
}

/// @nodoc
class _$ThreeAxisSensorCopyWithImpl<$Res>
    implements $ThreeAxisSensorCopyWith<$Res> {
  _$ThreeAxisSensorCopyWithImpl(this._value, this._then);

  final ThreeAxisSensor _value;
  // ignore: unused_field
  final $Res Function(ThreeAxisSensor) _then;

  @override
  $Res call({
    Object x = freezed,
    Object y = freezed,
    Object z = freezed,
  }) {
    return _then(_value.copyWith(
      x: x == freezed ? _value.x : x as double,
      y: y == freezed ? _value.y : y as double,
      z: z == freezed ? _value.z : z as double,
    ));
  }
}

/// @nodoc
abstract class _$ThreeAxisSensorCopyWith<$Res>
    implements $ThreeAxisSensorCopyWith<$Res> {
  factory _$ThreeAxisSensorCopyWith(
          _ThreeAxisSensor value, $Res Function(_ThreeAxisSensor) then) =
      __$ThreeAxisSensorCopyWithImpl<$Res>;
  @override
  $Res call({double x, double y, double z});
}

/// @nodoc
class __$ThreeAxisSensorCopyWithImpl<$Res>
    extends _$ThreeAxisSensorCopyWithImpl<$Res>
    implements _$ThreeAxisSensorCopyWith<$Res> {
  __$ThreeAxisSensorCopyWithImpl(
      _ThreeAxisSensor _value, $Res Function(_ThreeAxisSensor) _then)
      : super(_value, (v) => _then(v as _ThreeAxisSensor));

  @override
  _ThreeAxisSensor get _value => super._value as _ThreeAxisSensor;

  @override
  $Res call({
    Object x = freezed,
    Object y = freezed,
    Object z = freezed,
  }) {
    return _then(_ThreeAxisSensor(
      x: x == freezed ? _value.x : x as double,
      y: y == freezed ? _value.y : y as double,
      z: z == freezed ? _value.z : z as double,
    ));
  }
}

/// @nodoc
class _$_ThreeAxisSensor implements _ThreeAxisSensor {
  const _$_ThreeAxisSensor({this.x, this.y, this.z});

  @override
  final double x;
  @override
  final double y;
  @override
  final double z;

  @override
  String toString() {
    return 'ThreeAxisSensor(x: $x, y: $y, z: $z)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ThreeAxisSensor &&
            (identical(other.x, x) ||
                const DeepCollectionEquality().equals(other.x, x)) &&
            (identical(other.y, y) ||
                const DeepCollectionEquality().equals(other.y, y)) &&
            (identical(other.z, z) ||
                const DeepCollectionEquality().equals(other.z, z)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(x) ^
      const DeepCollectionEquality().hash(y) ^
      const DeepCollectionEquality().hash(z);

  @override
  _$ThreeAxisSensorCopyWith<_ThreeAxisSensor> get copyWith =>
      __$ThreeAxisSensorCopyWithImpl<_ThreeAxisSensor>(this, _$identity);
}

abstract class _ThreeAxisSensor implements ThreeAxisSensor {
  const factory _ThreeAxisSensor({double x, double y, double z}) =
      _$_ThreeAxisSensor;

  @override
  double get x;
  @override
  double get y;
  @override
  double get z;
  @override
  _$ThreeAxisSensorCopyWith<_ThreeAxisSensor> get copyWith;
}

/// @nodoc
class _$TwoAxisSensorTearOff {
  const _$TwoAxisSensorTearOff();

// ignore: unused_element
  _TwoAxisSensor call({double x, double y}) {
    return _TwoAxisSensor(
      x: x,
      y: y,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $TwoAxisSensor = _$TwoAxisSensorTearOff();

/// @nodoc
mixin _$TwoAxisSensor {
  double get x;
  double get y;

  $TwoAxisSensorCopyWith<TwoAxisSensor> get copyWith;
}

/// @nodoc
abstract class $TwoAxisSensorCopyWith<$Res> {
  factory $TwoAxisSensorCopyWith(
          TwoAxisSensor value, $Res Function(TwoAxisSensor) then) =
      _$TwoAxisSensorCopyWithImpl<$Res>;
  $Res call({double x, double y});
}

/// @nodoc
class _$TwoAxisSensorCopyWithImpl<$Res>
    implements $TwoAxisSensorCopyWith<$Res> {
  _$TwoAxisSensorCopyWithImpl(this._value, this._then);

  final TwoAxisSensor _value;
  // ignore: unused_field
  final $Res Function(TwoAxisSensor) _then;

  @override
  $Res call({
    Object x = freezed,
    Object y = freezed,
  }) {
    return _then(_value.copyWith(
      x: x == freezed ? _value.x : x as double,
      y: y == freezed ? _value.y : y as double,
    ));
  }
}

/// @nodoc
abstract class _$TwoAxisSensorCopyWith<$Res>
    implements $TwoAxisSensorCopyWith<$Res> {
  factory _$TwoAxisSensorCopyWith(
          _TwoAxisSensor value, $Res Function(_TwoAxisSensor) then) =
      __$TwoAxisSensorCopyWithImpl<$Res>;
  @override
  $Res call({double x, double y});
}

/// @nodoc
class __$TwoAxisSensorCopyWithImpl<$Res>
    extends _$TwoAxisSensorCopyWithImpl<$Res>
    implements _$TwoAxisSensorCopyWith<$Res> {
  __$TwoAxisSensorCopyWithImpl(
      _TwoAxisSensor _value, $Res Function(_TwoAxisSensor) _then)
      : super(_value, (v) => _then(v as _TwoAxisSensor));

  @override
  _TwoAxisSensor get _value => super._value as _TwoAxisSensor;

  @override
  $Res call({
    Object x = freezed,
    Object y = freezed,
  }) {
    return _then(_TwoAxisSensor(
      x: x == freezed ? _value.x : x as double,
      y: y == freezed ? _value.y : y as double,
    ));
  }
}

/// @nodoc
class _$_TwoAxisSensor implements _TwoAxisSensor {
  const _$_TwoAxisSensor({this.x, this.y});

  @override
  final double x;
  @override
  final double y;

  @override
  String toString() {
    return 'TwoAxisSensor(x: $x, y: $y)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TwoAxisSensor &&
            (identical(other.x, x) ||
                const DeepCollectionEquality().equals(other.x, x)) &&
            (identical(other.y, y) ||
                const DeepCollectionEquality().equals(other.y, y)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(x) ^
      const DeepCollectionEquality().hash(y);

  @override
  _$TwoAxisSensorCopyWith<_TwoAxisSensor> get copyWith =>
      __$TwoAxisSensorCopyWithImpl<_TwoAxisSensor>(this, _$identity);
}

abstract class _TwoAxisSensor implements TwoAxisSensor {
  const factory _TwoAxisSensor({double x, double y}) = _$_TwoAxisSensor;

  @override
  double get x;
  @override
  double get y;
  @override
  _$TwoAxisSensorCopyWith<_TwoAxisSensor> get copyWith;
}

/// @nodoc
class _$AngleSensorTearOff {
  const _$AngleSensorTearOff();

// ignore: unused_element
  _AngleSensor call({double pitch, double roll, double yaw}) {
    return _AngleSensor(
      pitch: pitch,
      roll: roll,
      yaw: yaw,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AngleSensor = _$AngleSensorTearOff();

/// @nodoc
mixin _$AngleSensor {
  double get pitch;
  double get roll;
  double get yaw;

  $AngleSensorCopyWith<AngleSensor> get copyWith;
}

/// @nodoc
abstract class $AngleSensorCopyWith<$Res> {
  factory $AngleSensorCopyWith(
          AngleSensor value, $Res Function(AngleSensor) then) =
      _$AngleSensorCopyWithImpl<$Res>;
  $Res call({double pitch, double roll, double yaw});
}

/// @nodoc
class _$AngleSensorCopyWithImpl<$Res> implements $AngleSensorCopyWith<$Res> {
  _$AngleSensorCopyWithImpl(this._value, this._then);

  final AngleSensor _value;
  // ignore: unused_field
  final $Res Function(AngleSensor) _then;

  @override
  $Res call({
    Object pitch = freezed,
    Object roll = freezed,
    Object yaw = freezed,
  }) {
    return _then(_value.copyWith(
      pitch: pitch == freezed ? _value.pitch : pitch as double,
      roll: roll == freezed ? _value.roll : roll as double,
      yaw: yaw == freezed ? _value.yaw : yaw as double,
    ));
  }
}

/// @nodoc
abstract class _$AngleSensorCopyWith<$Res>
    implements $AngleSensorCopyWith<$Res> {
  factory _$AngleSensorCopyWith(
          _AngleSensor value, $Res Function(_AngleSensor) then) =
      __$AngleSensorCopyWithImpl<$Res>;
  @override
  $Res call({double pitch, double roll, double yaw});
}

/// @nodoc
class __$AngleSensorCopyWithImpl<$Res> extends _$AngleSensorCopyWithImpl<$Res>
    implements _$AngleSensorCopyWith<$Res> {
  __$AngleSensorCopyWithImpl(
      _AngleSensor _value, $Res Function(_AngleSensor) _then)
      : super(_value, (v) => _then(v as _AngleSensor));

  @override
  _AngleSensor get _value => super._value as _AngleSensor;

  @override
  $Res call({
    Object pitch = freezed,
    Object roll = freezed,
    Object yaw = freezed,
  }) {
    return _then(_AngleSensor(
      pitch: pitch == freezed ? _value.pitch : pitch as double,
      roll: roll == freezed ? _value.roll : roll as double,
      yaw: yaw == freezed ? _value.yaw : yaw as double,
    ));
  }
}

/// @nodoc
class _$_AngleSensor implements _AngleSensor {
  const _$_AngleSensor({this.pitch, this.roll, this.yaw});

  @override
  final double pitch;
  @override
  final double roll;
  @override
  final double yaw;

  @override
  String toString() {
    return 'AngleSensor(pitch: $pitch, roll: $roll, yaw: $yaw)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AngleSensor &&
            (identical(other.pitch, pitch) ||
                const DeepCollectionEquality().equals(other.pitch, pitch)) &&
            (identical(other.roll, roll) ||
                const DeepCollectionEquality().equals(other.roll, roll)) &&
            (identical(other.yaw, yaw) ||
                const DeepCollectionEquality().equals(other.yaw, yaw)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(pitch) ^
      const DeepCollectionEquality().hash(roll) ^
      const DeepCollectionEquality().hash(yaw);

  @override
  _$AngleSensorCopyWith<_AngleSensor> get copyWith =>
      __$AngleSensorCopyWithImpl<_AngleSensor>(this, _$identity);
}

abstract class _AngleSensor implements AngleSensor {
  const factory _AngleSensor({double pitch, double roll, double yaw}) =
      _$_AngleSensor;

  @override
  double get pitch;
  @override
  double get roll;
  @override
  double get yaw;
  @override
  _$AngleSensorCopyWith<_AngleSensor> get copyWith;
}

/// @nodoc
class _$SensorResponseTearOff {
  const _$SensorResponseTearOff();

// ignore: unused_element
  _SensorResponse call(
      {@nullable AngleSensor angles,
      @nullable ThreeAxisSensor accelerometer,
      @nullable ThreeAxisSensor gyro,
      @nullable TwoAxisSensor position,
      @nullable TwoAxisSensor velocity}) {
    return _SensorResponse(
      angles: angles,
      accelerometer: accelerometer,
      gyro: gyro,
      position: position,
      velocity: velocity,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $SensorResponse = _$SensorResponseTearOff();

/// @nodoc
mixin _$SensorResponse {
  @nullable
  AngleSensor get angles;
  @nullable
  ThreeAxisSensor get accelerometer;
  @nullable
  ThreeAxisSensor get gyro;
  @nullable
  TwoAxisSensor get position;
  @nullable
  TwoAxisSensor get velocity;

  $SensorResponseCopyWith<SensorResponse> get copyWith;
}

/// @nodoc
abstract class $SensorResponseCopyWith<$Res> {
  factory $SensorResponseCopyWith(
          SensorResponse value, $Res Function(SensorResponse) then) =
      _$SensorResponseCopyWithImpl<$Res>;
  $Res call(
      {@nullable AngleSensor angles,
      @nullable ThreeAxisSensor accelerometer,
      @nullable ThreeAxisSensor gyro,
      @nullable TwoAxisSensor position,
      @nullable TwoAxisSensor velocity});

  $AngleSensorCopyWith<$Res> get angles;
  $ThreeAxisSensorCopyWith<$Res> get accelerometer;
  $ThreeAxisSensorCopyWith<$Res> get gyro;
  $TwoAxisSensorCopyWith<$Res> get position;
  $TwoAxisSensorCopyWith<$Res> get velocity;
}

/// @nodoc
class _$SensorResponseCopyWithImpl<$Res>
    implements $SensorResponseCopyWith<$Res> {
  _$SensorResponseCopyWithImpl(this._value, this._then);

  final SensorResponse _value;
  // ignore: unused_field
  final $Res Function(SensorResponse) _then;

  @override
  $Res call({
    Object angles = freezed,
    Object accelerometer = freezed,
    Object gyro = freezed,
    Object position = freezed,
    Object velocity = freezed,
  }) {
    return _then(_value.copyWith(
      angles: angles == freezed ? _value.angles : angles as AngleSensor,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer as ThreeAxisSensor,
      gyro: gyro == freezed ? _value.gyro : gyro as ThreeAxisSensor,
      position:
          position == freezed ? _value.position : position as TwoAxisSensor,
      velocity:
          velocity == freezed ? _value.velocity : velocity as TwoAxisSensor,
    ));
  }

  @override
  $AngleSensorCopyWith<$Res> get angles {
    if (_value.angles == null) {
      return null;
    }
    return $AngleSensorCopyWith<$Res>(_value.angles, (value) {
      return _then(_value.copyWith(angles: value));
    });
  }

  @override
  $ThreeAxisSensorCopyWith<$Res> get accelerometer {
    if (_value.accelerometer == null) {
      return null;
    }
    return $ThreeAxisSensorCopyWith<$Res>(_value.accelerometer, (value) {
      return _then(_value.copyWith(accelerometer: value));
    });
  }

  @override
  $ThreeAxisSensorCopyWith<$Res> get gyro {
    if (_value.gyro == null) {
      return null;
    }
    return $ThreeAxisSensorCopyWith<$Res>(_value.gyro, (value) {
      return _then(_value.copyWith(gyro: value));
    });
  }

  @override
  $TwoAxisSensorCopyWith<$Res> get position {
    if (_value.position == null) {
      return null;
    }
    return $TwoAxisSensorCopyWith<$Res>(_value.position, (value) {
      return _then(_value.copyWith(position: value));
    });
  }

  @override
  $TwoAxisSensorCopyWith<$Res> get velocity {
    if (_value.velocity == null) {
      return null;
    }
    return $TwoAxisSensorCopyWith<$Res>(_value.velocity, (value) {
      return _then(_value.copyWith(velocity: value));
    });
  }
}

/// @nodoc
abstract class _$SensorResponseCopyWith<$Res>
    implements $SensorResponseCopyWith<$Res> {
  factory _$SensorResponseCopyWith(
          _SensorResponse value, $Res Function(_SensorResponse) then) =
      __$SensorResponseCopyWithImpl<$Res>;
  @override
  $Res call(
      {@nullable AngleSensor angles,
      @nullable ThreeAxisSensor accelerometer,
      @nullable ThreeAxisSensor gyro,
      @nullable TwoAxisSensor position,
      @nullable TwoAxisSensor velocity});

  @override
  $AngleSensorCopyWith<$Res> get angles;
  @override
  $ThreeAxisSensorCopyWith<$Res> get accelerometer;
  @override
  $ThreeAxisSensorCopyWith<$Res> get gyro;
  @override
  $TwoAxisSensorCopyWith<$Res> get position;
  @override
  $TwoAxisSensorCopyWith<$Res> get velocity;
}

/// @nodoc
class __$SensorResponseCopyWithImpl<$Res>
    extends _$SensorResponseCopyWithImpl<$Res>
    implements _$SensorResponseCopyWith<$Res> {
  __$SensorResponseCopyWithImpl(
      _SensorResponse _value, $Res Function(_SensorResponse) _then)
      : super(_value, (v) => _then(v as _SensorResponse));

  @override
  _SensorResponse get _value => super._value as _SensorResponse;

  @override
  $Res call({
    Object angles = freezed,
    Object accelerometer = freezed,
    Object gyro = freezed,
    Object position = freezed,
    Object velocity = freezed,
  }) {
    return _then(_SensorResponse(
      angles: angles == freezed ? _value.angles : angles as AngleSensor,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer as ThreeAxisSensor,
      gyro: gyro == freezed ? _value.gyro : gyro as ThreeAxisSensor,
      position:
          position == freezed ? _value.position : position as TwoAxisSensor,
      velocity:
          velocity == freezed ? _value.velocity : velocity as TwoAxisSensor,
    ));
  }
}

/// @nodoc
class _$_SensorResponse implements _SensorResponse {
  const _$_SensorResponse(
      {@nullable this.angles,
      @nullable this.accelerometer,
      @nullable this.gyro,
      @nullable this.position,
      @nullable this.velocity});

  @override
  @nullable
  final AngleSensor angles;
  @override
  @nullable
  final ThreeAxisSensor accelerometer;
  @override
  @nullable
  final ThreeAxisSensor gyro;
  @override
  @nullable
  final TwoAxisSensor position;
  @override
  @nullable
  final TwoAxisSensor velocity;

  @override
  String toString() {
    return 'SensorResponse(angles: $angles, accelerometer: $accelerometer, gyro: $gyro, position: $position, velocity: $velocity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SensorResponse &&
            (identical(other.angles, angles) ||
                const DeepCollectionEquality().equals(other.angles, angles)) &&
            (identical(other.accelerometer, accelerometer) ||
                const DeepCollectionEquality()
                    .equals(other.accelerometer, accelerometer)) &&
            (identical(other.gyro, gyro) ||
                const DeepCollectionEquality().equals(other.gyro, gyro)) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality()
                    .equals(other.position, position)) &&
            (identical(other.velocity, velocity) ||
                const DeepCollectionEquality()
                    .equals(other.velocity, velocity)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(angles) ^
      const DeepCollectionEquality().hash(accelerometer) ^
      const DeepCollectionEquality().hash(gyro) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(velocity);

  @override
  _$SensorResponseCopyWith<_SensorResponse> get copyWith =>
      __$SensorResponseCopyWithImpl<_SensorResponse>(this, _$identity);
}

abstract class _SensorResponse implements SensorResponse {
  const factory _SensorResponse(
      {@nullable AngleSensor angles,
      @nullable ThreeAxisSensor accelerometer,
      @nullable ThreeAxisSensor gyro,
      @nullable TwoAxisSensor position,
      @nullable TwoAxisSensor velocity}) = _$_SensorResponse;

  @override
  @nullable
  AngleSensor get angles;
  @override
  @nullable
  ThreeAxisSensor get accelerometer;
  @override
  @nullable
  ThreeAxisSensor get gyro;
  @override
  @nullable
  TwoAxisSensor get position;
  @override
  @nullable
  TwoAxisSensor get velocity;
  @override
  _$SensorResponseCopyWith<_SensorResponse> get copyWith;
}
